![[Pasted image 20231112175924.png]]![[Pasted image 20231112175951.png]]
Signals are software interrupts.
Primitive form of interprocess communication(IPC).

POSIX standardized signal handling.

This chapter will discuss use and <u>misuse</u>, manage and manipulate signals.

# Signal Concepts
a signal is raised(sent),stored by kernel, which perform one of three actions, depending on process asked kernel to do. 
*Ignore the signal*
+ exception: SIGKILL and SIGSTOP
*Catch and handle the signal*
+ example:SIGINT..user generating interrupt char.
+ SIGTERM..processes catch SIGTERM to perform necessary cleanup, such like disconnect from network, removing temporary files.
+ SIGKILL, SIGSTOP can't be caught.
*Perform the default action*
+ default action is oftern terminate the proccess.(SIGKILL is)
Nowadays, signals can pass user-defined data.
## Signal Identifiers
- defined in <signal.h>, they are positive integers(integer identifier)
- First dozen or so signals are usually same(SIGKILL is infamously signal 9)

- There is no signal with the value 0, nonetheless, which has a name null signal.
- some system calls(e.g. kill()) user a value of 0.
> `kill -l` to list signals.

| Signal  | Description                                      | Default Action           |
|---------|--------------------------------------------------|--------------------------|
| SIGABRT | Sent by abort()                                  | Terminate with core dump |
| SIGALRM | Sent by alarm()                                  | Terminate                |
| SIGBUS  | Hardware or alignment error                      | Terminate with core dump |
| SIGCHLD | Child has terminated                             | Ignored                  |
| SIGCONT | Process has continued after being stopped        | Ignored                  |
| SIGFPE  | Arithmetic exception                             | Terminate with core dump |
| SIGHUP  | Processâ€™s controlling terminal was closed        | Terminate                |
| SIGILL  | Process tried to execute an illegal instruction  | Terminate with core dump |
| SIGINT  | User generated the interrupt character (Ctrl-C)  | Terminate                |
| SIGIO   | Asynchronous I/O event                           | Terminate                |
| SIGKILL | Uncatchable process termination                  | Terminate                |
| SIGPIPE | Process wrote to a pipe but there are no readers | Terminate                |
| SIGPROF | Profiling timer expired                          | Terminate                |
| SIGPWR  | Power failure                                    | Terminate                |
| SIGQUIT | User generated the quit character (Ctrl-)        | Terminate with core dump |
| SIGSEGV   | Memory access violation                                           | Terminate with core dump |
| SIGSTKFLT | Coprocessor stack fault                                           | Terminate                |
| SIGSTOP   | Suspends execution of the process                                 | Stop                     |
| SIGSYS    | Process tried to execute an invalid system call                   | Terminate with core dump |
| SIGTERM   | Catchable process termination                                     | Terminate                |
| SIGTRAP   | Breakpoint encountered                                            | Terminate with core dump |
| SIGTSTP   | User generated the suspend character (Ctrl-Z)                     | Stop                     |
| SIGTTIN   | Background process read from controlling terminal                 | Stop                     |
| SIGTTOU   | Background process wrote to controlling terminal                  | Stop                     |
| SIGURG    | Urgent I/O pending                                                | Ignored                  |
| SIGUSR1   | Process-defined signal                                            | Terminate                |
| SIGUSR2   | Process-defined signal                                            | Terminate                |
| SIGVTALRM | Generated by setitimer() when called with the ITIMER_VIRTUAL flag | Terminate                |
| SIGWINCH  | Size of controlling terminal window changed                       | Ignored                  |
| SIGXCPU   | Processor resource limits were exceeded                           | Terminate with core dump |
| SIGXFSZ   | File resource limits were exceeded                                | Terminate with core dump |

SIGINFO is SIGPWR, SIGIOT is SIGABRT, SIGPOLL,SIGLOST are SIGIO.
SIGABRT:
- func abort() sends this signal.The process terminates and gen core file. In Linux, assert() call abort().
SIGALRM:
- `alarm()` and `setitimer()`(with `ITIMER_REAL` flag) send the signal to the process that invoked them when an alarm expires. See [[Chapter 11]].
SIGBUS:
- The kernel raises the signal when process incurs a hardware fault(except, memory protection gens a SIGSEGV.
-  On Unix Systems, it represented various errors.
-  The Linux kernel fixs most of these errors, automatically.
	-  However, the kernel does raise when improperly access memory created via mmap(). See [[Chapter 9]]
SIGCHLD:
- When process terminates or stops, the kernel sends the signal to the parent. By default, it is ignored. A handler for the signal generally calls wait(). See [[Chapter 5]].
SIGCONT:
- Kernel -> Process when the process is resumed. By default, it is ignored. Commonly used by terminals or editors to refresh the screen.
SIGFPE:
- Arithmetic exception(e.g. floating-point, overflows, underflows, div-by-zero). Behavior of  process and the result of the offending operation are undefined if it continue.
SIGHUP:
- Kernel -> session leader when the session's terminal disconnects.
- Kernel -> each process in the fg process group when the session's leader terminates.
- Default action is terminate since SIGHUP suggests user logged out.
- Daemon processes "overload" the signal to reload config files.
	- (e.g.)SIGHUP -> Apache will reread *httpd.conf.*
	- The practice is safe, bc daemons don't have controlling terminals and should never normally receive the signal[^1]
SIGILL:
- Kernel sends when a process attempt illegal machine instruction.
`SIGINT`
- send to all processes in the fg process group when the user interrupt character(usually \<C-C\>)
SIGIO:
- is sent when a BSD-style asynchronous I/O event is gened. Rare I/O on Linux. See [[Chapter 4]] for advanced I/O tech common to Linux)
SIGKILL:
- is sent from the kill() system call; unconditional kill. can't be caught or ignored. always terminate.
SIGPIPE:
- The kernel raises the signal if a process writes to a pipe but the reader has terminated.
SIGPROF:
- setitimer() func with ITIMER_PROF flag gens the signal when profiling timer express.
SIGPWR:
- On Linux, represents a low-battery condition. UPS monitoring daemon sends the signal to *init*.
SIGQUIT:
- The kernel raises this for all processes in the fg process group when user provides the terminal quit character(<C-\\>)
SIGSEGV:
- name derives from *segmentation violation*
- is sent to a process when it attempts an invalid memory access(e.g. access unmapped memory, reading from none-readable, executing code in memory)
SIGSTOP:
- sent only by kill(). Unconditionally stop and can't be caught or ignored.
SIGSYS:
- The kernel -> process when it attempts to invoke an invalid system call.
- could happen when a binary runs older version OS.
- properly built binaries through *glibc* should never return this, instead return -1 and set errno to ENOSYS.
SIGTERM:
- is sent only by `kill();
- gracefully terminate a process. Processes may elect to catch this signal and clean up before terminating, but it is considered <u>rude to</u> catch the signal and not terminate promptly.
SIGTRAP:
- The kernel -> a process when it crosses a break point.
- debuggers catch this generally. Others ignore it.
SIGTTIN:
- sent to a bg process when it attempts to read from its controlling terminal.
SIGTTOU:
- sent to a bg process when it attempts to write to its controlling terminal.
SIGURG:
- The kernel -> a process when OOB(out-of-band)data has arrived on socket.
SIGUSR1, SIGUSR2
- kernel never raises them. Processes may use them for whatever purpose they like.
- Commonly, instruct a daemon process to behave differently. The default action is to terminate the process.
SIGVTALRM:
- The `setitimer()` func sends the signal when timer with `ITIMER_VIRTUAL`flag expires. See [[Chapter 11]].
SIGWINCH:
- The kernel raises this for all processes in the fg process group when terminal window size changes.
- By default, processes ignore this.
- *top* program catches this.
SIGXCPU:
- The kernel raises this when process exceeds soft processor limit.
- The kernel continues raise this per sec until exits or exceeds its hard processor limit.
SIGXFSZ:
- The kernel raises this when a process exceeds its file size limit. The default action is to terminate the process.
- However if caught or ignored, the sys call returns -1 and set errno to EFBIG.
# Basic Signal Management
- The simplest and oldest interface for signal management is the `signal()` func.
- Defined by the ISO C89 standard.
```c
#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signo, sighandler_t handler);
```
- If successfully called, `signal()` handles the signal with 2nd arg `handler` instead of the current action.
- a process can catch neither `SIGKILL`nor `SIGSTOP`, so in those case 2nd arg is meaningless.
- `handler`func must return `void`, bc there is no std place to return in the program.
	- Linux uses a typedef, `sighandler_t` to define.
	- Other Unix systems directly use the func pointers.
	- some have own types, which not be named `sighandler_t.`
	- Programs seeking portability shouldn't ref the type.
- when raises a signal to process -> kernel suspends exec of prog instruction stream -> calls signal handler -> handler with `signo` from `signal()`
- Also, use `signal()` to instruct kernel to ignore a signal or reset the signal to the default behavior by using handler parameter:
	- `SIG_DEL`
		- set the behavior to its default.
	- `SIG_IGN`
		- Ignore the signal given by `signo`.
- The `signal()` func returns the previous behavior of the signal, which could be a pointer to a signal handler, `SIG_DEL`, `SIG_IGN`.
	- On error, the func returns `SIG_ERR`, doesn't set `errno`.
## Waiting for a Signal, Any Signal
- the POSIX-defined `pause()` sys call puts a process to sleep until it receives a signal the either handled or terminates the process.
``` c
#include <unistd.h>
int pause (void);
```
- `puase()` returns only when a signal is received, in which case the signal is handled, and `pause()` returns -1 and sets `errno` to `EINTR`.[^2] If the kernel raises an ignored signal, the process doesn't wake up.
	- In the Linux kernel, `puase()` is one of the simplest sys calls. It performs only 2 actions.(`getpid(),gettid()` each only 1 line.)
	- It puts the process in the interruptible sleep state.
	- calls `schedule()` to invoke the Linux process scheduler to find another process to run.
## Example
```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
/* handler for SIGINT and SIGTERM */
static void signal_handler (int signo)
{
 if (signo == SIGINT)
 printf ("Caught SIGINT!\n");
 else if (signo == SIGTERM)
 printf ("Caught SIGTERM!\n");
 else {
 /* this should never happen */
 fprintf (stderr, "Unexpected signal!\n");
 exit (EXIT_FAILURE);
 }
 exit (EXIT_SUCCESS);
}
int main (void)
{
 /*
 * Register signal_handler as our signal handler
 * for SIGINT.
 */
 if (signal (SIGINT, signal_handler) == SIG_ERR) {
 fprintf (stderr, "Cannot handle SIGINT!\n");
 exit (EXIT_FAILURE);
 }
 /*
 * Register signal_handler as our signal handler
 * for SIGTERM.
 */
 if (signal (SIGTERM, signal_handler) == SIG_ERR) {
 fprintf (stderr, "Cannot handle SIGTERM!\n");
 exit (EXIT_FAILURE);
 }
 /* Reset SIGPROF's behavior to the default. */
 if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
 fprintf (stderr, "Cannot reset SIGPROF!\n");
 exit (EXIT_FAILURE);
 }
 /* Ignore SIGHUP. */
 if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
 fprintf (stderr, "Cannot ignore SIGHUP!\n");
 exit (EXIT_FAILURE);
 }
 for (;;)
 pause ();
 return 0;
}```
## Execution and Inheritance
- On fork, the child inherits the signal actions(ignore, default, handle) of parent.
- Pending signals are *not* inherited, make sense, bc was sent to a specific pid, decidedly not the child.
- *exec* family of sys calls create process, all signals are default actions.
	- unless the parent process is ignoring them.
	- another way, all signal before *exec* will be default action after *exec*
		- make sense bc a freshly executed process doesn't share the addr space of its parent, thus signal handlers may not exist.
	- Pending signals are inherited.

| Signal Behavior | Across Forks  | Across Execs  |
|-----------------|---------------|---------------|
| Ignored         | Inherited     | Inherited     |
| Default         | Inherited     | Inherited     |
| Handled         | Inherited     | Not Inherited |
| Pending signals | Not Inherited | Inherited     |
- notable use:
	- when shell(or another bg procs) executes bg procs, the new one should ignore the interrupt and quit chars.
	- Thus, a shell before executes a bg proc, it should set `SIGINT` and `SIGQUIT` to `SIG_IGN`.
	- It's common to first check these signals not ignored.
```c
/* handle SIGINT, but only if it isn't ignored */
if (signal (SIGINT, SIG_IGN) != SIG_IGN) {
    if (signal (SIGINT, sigint_handler) == SIG_ERR)
        fprintf (stderr, "Failed to handle SIGINT!\n");
}
```
- set a signal behavior to check the signal behavior is a deficiency in the `signal()` interface.
## Mapping Signal Numbers to Strings
1. `extern const char * const sys_siglist[];`
2. BSD-defined `psinal()`interface, which is common enough that Linux supports it, too.
	```c
	#include <signal.h>
	void psignal (int signo, const char *msg);
	```
	- prints to `stderr` `msg`string: name of signal given by `signo`.
3. `strsignal()` is better interface. 
	```c
	#define _GNU_SOURCE
	#include <string.h>
	char * strsignal (int signo);
	```
	- return description of the signal.
	- returned str is valid only until the next invocation of `strsignal()`, so it isn't thread-safe.
4. `sys_siglist` is the best.
```c
static void signal_handler (int signo)
{
	printf ("Caught %s\n", sys_siglist[signo]);
}
```
# Sending a Signal
- The `kill()` sys call, sends a signal from one proc to another.
 ```c
	#include <sys/types.h>
	#include <signal.h>
	int kill (pid_t pid, int signo);
 ```
- if`pid` >0, `signo` is sent to `pid`.
- if`pid` == 0, `signo` is sent to every proc in the invoking process's process group.
- if`pid` == -1, `signo` is sent to every proc which invoking one has perm to send a signal, except itself and *init*.
- if`pid` < -1, `signo` is sent to process group -pid.
RETURN VALUE
- so long as a single signal was sent, returns 0.
- Else, returns -1, and `errno` is
	- `EINVAL`: `signo` is invalid.
	- `EPERM`: lacks sufficient perm to send.
	- `ESRCH`: proc or proc group denoted by `pid` is zombie.
## Permissions
- A proc with `CAP_KILL` capability can send a signal.
- or proc's effective or real user ID == real or saved user ID of recieving proc.
	- user can send signal to he owns.
>Unix sys, including Linux, has exception for `SIGCONT`. It can send the signal to any proc in the same session.

If `sigo` == 0, the call won't send a signal, but do check error. This is useful to check permissions.
## Examples
```c
int ret;
ret = kill(1722, SIGHUP);
if (ret)
	perror ("kill");
```
which is same as `$ kill -HUP 1722`
check permi.
```c
int ret;
ret = kill (1722, 0);
if (ret)
	; /* we lack permission */
else
	; /* we have permission */
```
## Sending a Signal to Yourself
```c
#include <signal.h>
int raise (int signo);

// this doesn't set `ERRNO`
raise (signo); // is equal to
kill (getpid(), signo);
```
## Sending a Signal to an Entire Process Group
```c
#include <signal.h>
int killpg (int pgrp, int signo);

killpg (pgrp, signo); // is equal to
kill (-pgrp, signo);
```
- even if `pgrp` = 0, this holds true.`signo` is sent to every proc in the invoking proc's group.
- RETURN VALUE is 0 and -1, and `errno` is
	- `EINVAL`: `signo`invalid.
	- `EPERM`: lack permi.
	- `ESRCH`: `pgrp`doesn't exist.
# Reentrancy
- the moments the kernel raises a signal can be anytime.
	- Middle of key ope which will be unsafe.
	- Handling another signal.
- Signal handlers must take care, when modifying global(shared) data.
- next section will temporarily block the signals.
- if the signal handler invokes same non-reentrant func in the middle of non-reentrant func, it'll be chaos.
- *reentrant func* is a func safe to call within itself
	- or concurrently from another thread in the same procs.
- in order to qualify as reentrant,
	 - use only stack-allocated, data by the caller, must not invoke any non-reentrant func.
## Guanranteed-Reentrant Functions
- have to assume the process could be executing non-reentrant func, thus signal handlers must make use only reentrant.
- *signal-safe*(reentrant and thus safe to use from within a signal handler) list
- ```
```c
abort() accept() access() aio_error() aio_return() aio_suspend() alarm() bind() cfgetispeed() cfgetospeed() cfsetispeed() cfsetospeed() chdir() chmod() chown() clock_gettime() close() connect() creat() dup() dup2() execle() execve() \_Exit() \_exit() fchmod() fchown() fcntl() fdatasync() fork() fpathconf() fstat() fsync() ftruncate() getegid() geteuid() getgid() getgroups() getpeername() getpgrp() getpid() getppid() getsockname() getsockopt() getuid() kill() link() listen() lseek() lstat() mkdir() mkfifo() open() pathconf() pause() pipe() poll() posix_trace_event() pselect() raise() read() readlink() recv() recvfrom() recvmsg() rename() rmdir() select() sem_post() send() sendmsg() sendto() setgid() setpgid() setsid() setsockopt() setuid() shutdown() sigaction() sigaddset() sigdelset() sigemptyset() sigfillset() sigismember() signal() sigpause() sigpending() sigprocmask() sigqueue() sigset() sigsuspend() sleep() socket() socketpair() stat() symlink() sysconf() tcdrain() tcflow() tcflush() tcgetattr() tcgetpgrp() tcsendbreak() tcsetattr() tcsetpgrp() time() timer_getoverrun() timer_gettime() timer_settime() times() umask() uname() unlink() utime() wait() waitpid() write()
``````
# Signal Sets
- standardized by POSIX and found on any modern Unix system.

```c
#include <signal.h>

// make it empty
int sigemptyset (sigset_t *set);

// make it full
int sigfillset (sigset_t *set);
int sigaddset (sigset_t *set, int signo); // add signo to the signal set
// both set errno to EINVAL.

// remove signo from signal set(errnoâ†’EINVAL)
int sigdelset (sigset_t *set, int signo);

// whether signo is in signal set
int sigismember (const sigset_t *set, int signo);
```

## More Signal Set Functions
- none-standard func
```c
#define _GNU_SOURCE
#define <signal.h>
int sigisemptyset (sigset_t *set);
int sigorset (sigset_t *dest, sigset_t *left, sigset_t *right);
int sigandset (sigset_t *dest, sigset_t *left, sigset_t *right);
```
# Blocking Signals
- when prog needs to share data b/w a signal handlers and elsewhere in the prog.
- *critical regions* are where *block* signals for no interruption wanted. 
- any signal are not raised until unblocked.
- *signal mask* is the set of signal blocked by a process.
- POSIX defines, and Linux implements
```c
#include <signal.h>
int sigprocmask (int how,
					const sigset_t *set,
					sigset_t *oldset);
```
- `how`
	- `SIG_SETMASK`: set `set`
	- `SIG_BLOCK`: add `set`
	- `SIG_UNBLOCK`: subtract `set` (illegal to subtract void)
success is 0, failure is -1, set `errno` to `EINVAL`when `how` was invalid, `EFALUT` when `set` or `oldset` was invalid.
- blocking `SIGKILL`,`SIGSTOP` is not allowed.
	- `sigprocmask()` silently ignores any add signal.
## Retrieving Pending Signals 
- *pending* signals are signals not delivered, when the kernel raises a block.
```c
#include <signal.h>
int sigprocmaski (int how, const sigset_t *set, sigset_t *oldset);//POSIX defined. EFALUT for invalid set
```
## Waiting for a Set of Signals
- proc to temporarily wait until a signal is raised to terminates or is handled by the proc. It's a third POSIX-defined func.
```c
#include <signal.h>
int sigsuspend (const sigset_t *set);
```
- signal terminates the proc -> `sigsuspend()` doesn't return
- raise and handled-> ret -1,`EINTR = errno`
- if invalid `EFALUT = errno`
- common scenario is `sigprocmask()` to block, save the old mask in `oldset`, after exiting the *critical region*, the proc then calls `sigsuspend()` 
# Advanced Signal Management
- above is basic, bc it's part of the standard C library.
- POSIX standardizes the `sigaction()` system call, providing much greater signal management capabilities.
```c
#include <signal.h>
int sigaction (int signo,
			   const struct sigaction *act,
			   struct sigaction *oldact);
```
- change the behavior of the signal id-ed by `signo`
	- except `SIGKILL` and `SIGSTOP`
 - if `act` isn't `NULL`, sys call changes the current behavior of the signal as specified by `act`
- if `oldact`â‰  `NULL`, the call stores prev behavior of the given signal there.
	- (or current if `act` is `NULL`)
```c
#include <sys/signal.h>
struct sigaction {
	void (*sa_handler)(int); /* signal handler or action */
	void (*sa_sigaction)(int, siginfo_t *, void *);
	sigset_t sa_mask; /* signals to block */
	int sa_flags; /* flags */
	void (*sa_restorer)(void); /* obsolete and non-POSIX */
};
```
- `sa_handler` field may be `SIG_DEL`,`SIG_IGN`, or a pointer to a signal-handling func.
	- the func has the same prototype installed by `signal()`
	- `void my_handler (int signo);`
- if `sa_flags` = `SA+SIGINFO`, `sa_sigaction`(not `sa_handler`) the following signal-handling func.
	- `void my_handler (int signo, siginfo_t *si, void *ucontext);`
 third arg is `ucontext_t`structure casting to a `void` pointer.
- on some archi, `sa_handler` and `sa_sigaction` are in a union, and shouldn't be assigned values in the same time.
- when `SA_NODEFER` in `sa_flags`, the current handled signal is also blocked.
	- as always, you can't block `SIGKILL` or `SIGSTOP`.
- other than `SA_SIGINFO`, `SA_NODEFER` flags,
	- `SA_NOCLDSTOP` don't notify when child proc stops or resume when `signo = SIGCHLD`
	 - `SA_NOCLDWAIT` enables *automatic child reaping*: children aren't be zombies when terminate. And parents needn't(and can't) call `wait()` on them. See [Chapter 5]
	 - `SA_NOMASK`obsolete. Use `SA_NODEFER`, but see the value turn up in older code(?)[^3]
	 - `SA_ONESHOT`:obsolete. Use `SA_RESETHAND`, but see the value turn up in older code(?)
	  - `SA_ONSTACK` use *alternative signal stack* provided by `sigaltstack()`
		  - useful in Pthreads app with smaller thread stacks might be overrun by some signal handler usage.
	  - `SA_RESTART`
		  - enable BSD-style restart of sys calls.
	  - `SA_RESETHAND`
		   - enable "one-shot" mode. the behavior of signal is reset to the default after returns.
	   - `sa-restorer` field is no longer used in Linux.
	- `sigaction()` failure is -1.
		- `errno`is
			- `EFAULT` `act`, `oldact` is invalid.
			- `EINVAL`  `signo` is invalid, `SIGKILL`, `SIGSTOP`
## The siginfo_t Structure
- also defined in <sys/signal.h>
```c
typedef struct siginfo_t {
	int si_signo; /* signal number */
	int si_errno; /* errno value */
	int si_code; /* signal code */
	pid_t si_pid; /* sending process's PID */
	uid_t si_uid; /* sending process's real UID */
	int si_status; /* exit value or signal */
	clock_t si_utime; /* user time consumed */
	clock_t si_stime; /* system time consumed */
	sigval_t si_value; /* signal payload value */
	int si_int; /* POSIX.1b signal */
	void *si_ptr; /* POSIX.1b signal */
	void *si_addr; /* memory location that caused fault */
	int si_band; /* band event */ int si_fd; /* file descriptor */
};
```
- 


[^1]: no idea
[^2]: no idea
[^3]: no idea